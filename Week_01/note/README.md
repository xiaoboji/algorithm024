本周主要学习了如下6种数据结构
# 数组
  
> 经典的定义:数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。数组支持随机访问，根据下标随机访问的时间复杂度为 O(1) 

中间有三个核心概念
- 线程表

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

与之相对应的是非线性表，非线性表中，数据之间并不是简单的前后关系,往往具有多前或者多后。比如二叉树、堆、图等。
- 连续的内存空间

即使整体内存足够，但是数据不连续，也无法初始化需要大小的数组。

- 相同类型的数据

java中即使现在有了泛型，在泛型擦除之后，也还是具体的相同的数据类型。

小结：

正是有了上述三个特点，才使得数组有了杀手锏一样的特性，随机访问。但是有利有弊，连续的内存空间和相同的数据类型，也使得数据的删除插入等操作低效，因为了保证连续性，就要移动大量的数据。

时间复杂度分析:

操作     | 时间复杂度
-------- | -----
插入  | O(N)
删除  | O(N)
修改  | O(1)
查询  | O(1)

# 链表

> 链表与数组恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。

- 单链表

只记录后继节点信息的链表，习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点

- 双向链表

单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

记录前后节点信息，查询比单链快，删除比单链简单，前插快，查找能类二分

- 循环链表

循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。

和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

时间复杂度：正好和数据想法
操作     | 时间复杂度
-------- | -----
插入  | O(1)
删除  | O(1)
修改  | O(N)
查询  | O(N)

# 跳表

Redis对于Set的优化实现方式，必须针对有序数据，指的是加多级索引的结构,支持类似“二分”的查找算法

# 栈

后进先出，先进后出，类似于叠盘子。

从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。

栈既可以通过数组实现，也可以通过链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。

不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)

栈只支持两个基本操作：入栈 push()和出栈 pop()

# 队列

先进先出，后进后出，类似于排队买票。

最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。

## 总结的blog链接

- [数据结构与算法(一)【数组】【详解及实战】](https://xiaoboji.blog.csdn.net/article/details/107009834)
- [数据结构与算法(二)【链表】【详解及编程技巧】](https://xiaoboji.blog.csdn.net/article/details/108612136)
- [数据结构与算法(三)【栈】【详解及应用】](https://xiaoboji.blog.csdn.net/article/details/108687655)
